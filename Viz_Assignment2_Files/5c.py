# -*- coding: utf-8 -*-
"""5c

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-cmCVoS1qbafZ4n1DMQfd5Mq9N4ovhQX
"""

import numpy as np
import matplotlib.pyplot as plt

# We are loading our data set here
scalar_field = np.load("scalars_2D.npy")
num_rows, num_cols = scalar_field.shape

# then we are defining or contour threshold
threshold = 50

# We define a function to plot point x and y
def plot_point(ax, x, y, color):
    ax.plot(x, y, marker='o', color=color, markersize=5)
    #ax.show()
# We define a segment to plot point x and y
def plot_segment(ax, x1, y1, x2, y2):
    ax.plot([x1, x2], [y1, y2], color='blue', linewidth=2)
   # ax.show()
# We define a segment to plot point x and y
def linear_interpolation(p1, p2, val1, val2, threshold):

    if abs(threshold - val1) < 1e-6:
        #print("In if statement")
        return p1
    if abs(threshold - val2) < 1e-6:
        return p2
    if abs(val1 - val2) < 1e-6:
        return p1
    return p1 + (p2 - p1) * (threshold - val1) / (val2 - val1)

# We then define our plot
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xlim(-0.5, num_cols - 0.5)
ax.set_ylim(-0.5, num_rows - 0.5)
ax.set_xticks(range(num_cols))
ax.set_yticks(range(num_rows))
ax.grid(True)

# Plot scalar field points
for r in range(num_rows - 1):
    for c in range(num_cols - 1):
        plot_point(ax, c + 0.5, r + 0.5, 'red' if scalar_field[r, c] > threshold else 'black')
        # plot_point.show()
# Next step is to implement Marching Squares
for r in range(num_rows - 1):
    for c in range(num_cols - 1):
        val1, val2 = scalar_field[r, c], scalar_field[r, c+1]
        val3, val4 = scalar_field[r+1, c], scalar_field[r+1, c+1]

        case_id = ((val1 > threshold) << 3) | ((val2 > threshold) << 2) | ((val4 > threshold) << 1) | (val3 > threshold)

        # calculate interpolated midpoints
        edge_top = (linear_interpolation(c, c+1, val1, val2, threshold), r)
        edge_bottom = (linear_interpolation(c, c+1, val3, val4, threshold), r+1)
        edge_left = (c, linear_interpolation(r, r+1, val1, val3, threshold))
        edge_right = (c+1, linear_interpolation(r, r+1, val2, val4, threshold))

        # Creating a Lookup table for contour segments
        contour_segments = {
            1: [edge_left, edge_bottom],
            2: [edge_bottom, edge_right],
            3: [edge_left, edge_right],
            4: [edge_top, edge_right],
            5: [edge_top, edge_left, edge_bottom, edge_right],
            6: [edge_top, edge_bottom],
            7: [edge_top, edge_left],
            8: [edge_top, edge_left],
            9: [edge_top, edge_bottom],
            10: [edge_top, edge_right, edge_left, edge_bottom],
            11: [edge_top, edge_right],
            12: [edge_left, edge_right],
            13: [edge_bottom, edge_right],
            14: [edge_left, edge_bottom],
        }

        # Plotting our created contour lines
        if case_id in contour_segments:
            points = contour_segments[case_id]
            #print(points)
            for k in range(0, len(points), 2):
                #print("Value of k:",k)
                plot_segment(ax, *points[k], *points[k+1])


plt.gca().invert_yaxis()
plt.show()

