# -*- coding: utf-8 -*-
"""Question_1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lwGG9VqoAtXWf9vv72OcwzbbdDzMQiyy
"""

import numpy as np
import matplotlib.pyplot as plt

# This creates an array an x of 100 evenly spaced numbers.
x = np.linspace(0, 1, 100)

# Function given to us in the question is y = sin(10πx) + sin(20πx)
y_actual = np.sin(10 * np.pi * x) + np.sin(20 * np.pi * x) #This actually hold the noise free value.

# Generate 100 noise samples
total_num = 100
y_noise = []

# This loops adds noise to the signal
for _ in range(total_num):
    # Calculate SD
    noise_std = np.abs(y_actual) / 2
    noise = np.random.normal(0, noise_std)
    # This steps adds noise
    y_noisy = y_actual + noise
    y_noise.append(y_noisy)

# Convert list to numpy array
y_noise_array = np.array(y_noise)

# Plot all the 100 lines
plt.figure(figsize=(8, 6))
for i in range(total_num):
    plt.plot(x, y_noise_array[i], linewidth=1)

plt.xlabel('x')
plt.ylabel('y')
plt.title('Noise')
plt.grid(False)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# This creates an array an x of 100 evenly spaced numbers.
x = np.linspace(0, 1, 100)

# Function given to us in the question is y = sin(10πx) + sin(20πx)
y_true = np.sin(10 * np.pi * x) + np.sin(20 * np.pi * x)

# Generate 100 noise samples
num_instances = 100
y_noisy_instances = []

# This loops adds noise to the signal
for _ in range(num_instances):
    noise_std = np.abs(y_true) / 2  # Standard deviation of the noise
    noise = np.random.normal(0, noise_std)  # Gaussian noise
    y_noisy = y_true + noise
    y_noisy_instances.append(y_noisy)

# Convert list to numpy array
y_noisy_array = np.array(y_noisy_instances)

# Calculate mean and standard deviation
y_mean = np.mean(y_noisy_array, axis=0)
y_std = np.std(y_noisy_array, axis=0)

# Here I am showig mean and std deviation as shaded region
plt.figure(figsize=(8, 6))
plt.plot(x, y_mean, color='navy', label='Mean of noisy y(x)')
plt.fill_between(x, y_mean - y_std, y_mean + y_std, color='blue', alpha=0.3, label='Std Dev')

plt.xlabel('x')
plt.ylabel('y')
plt.title('Mean and Standard Deviation of Noisy y(x)')
plt.legend()
plt.grid(False)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq
from scipy.signal import butter, filtfilt

# This here will create signal with both components for the given function in the question sin(10πx) + sin(20πx)
x = np.linspace(0, 1, 100)
y_func = np.sin(10 * np.pi * x) + np.sin(20 * np.pi * x)
std = np.abs(y_func) / 2
noisy_input = y_func + np.random.normal(0, std)

# Fourier Transform Function
N = len(x)
T = x[1] - x[0]
yf = fft(noisy_input)
xf = fftfreq(N, T)[:N // 2]

# Here I am applying Butterworth Bandpass Filter
low = 4.0
high = 6.0
order = 2
nyquist = 0.5 / T
low = low / nyquist
high = high / nyquist

b, a = butter(order, [low, high], btype='band')
filtered_data = filtfilt(b, a, noisy_input)

# Plotting
plt.figure(figsize=(14, 5))

# FFT
plt.subplot(1, 2, 1)
plt.plot(xf, 2.0 / N * np.abs(yf[0:N // 2]), color='royalblue')
plt.title('Fourier of Noisy Signal')
plt.xlabel('Frequency')
plt.ylabel('Magnitude')

# Plotting the results for the comparison
plt.subplot(1, 2, 2)
plt.plot(x, np.sin(10 * np.pi * x), label='Exact: sin(10πx)', color='steelblue', linewidth=2)
plt.plot(x, filtered_data, label='De-noised / Filtered Data', color='darkorange', linewidth=2)
plt.title('Filtered Signal Using Bandpass')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()

plt.tight_layout()
plt.show()

